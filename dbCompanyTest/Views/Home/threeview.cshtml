

	<style>
		body {
			margin: 0;
		}
		.webgl{
			/*position:fixed;
			top:0;
			left:0;*/
		}
	</style>
	<div class="3dtype">
		<canvas class="webgl"></canvas>

	</div>

@section Scripts{
	<script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
	@*gsap*@
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>

	<script>
		//Base
		const canvas = document.querySelector('canvas.webgl')
		//Scene
		const scene=new THREE.Scene();
		//TestCube
		const cubeGeometry=new THREE.BoxGeometry(1,1,1,1);
		const cubeMaterial=new THREE.MeshBasicMaterial({color: 0x92C3C8});
		const cube=new THREE.Mesh(cubeGeometry,cubeMaterial);
		scene.add(cube);
		//GLTF Loader
		let shiba=null;
		const gltfLoader = new THREE.GLTFLoader()
		gltfLoader.load(
			"@Url.Content("~/3d/shiba/scene.gltf")",
			(gltf)=>{
				console.log(gltf);
				shiba=gltf.scene;

				shiba.position.x = 1.5
				shiba.rotation.x = Math.PI*0.2
				shiba.rotation.z = Math.PI * 015

				const radius=8.5
				shiba.scale.set(radius,radius,radius)
				scene.add(shiba);
			})

		//Sizes
		const sizes ={
			width:window.innerWidth,
			height:window.innerHeight
		}
		//Camera
		const camera=new THREE.PerspectiveCamera(35,sizes.width / sizes.height,0.1,1000)
		camera.position.z=5
		scene.add(camera)
		//Light
		const ambientLight=new THREE.AmbientLight(0xffffff,1)
		scene.add(ambientLight);

		const directionalLight = new THREE.DirectionalLight(0xffffff,1)
		directionalLight.position.set(1,2,0)
		scene.add(directionalLight);
		//Renderer
		const renderer =new THREE.WebGL1Renderer({
			canvas:canvas,
			antialias: true,
			alpha: true
		})

		renderer.setSize(sizes.width,sizes.height)
		renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))



		//Animate
		const clock=new THREE.Clock()
		let  lastElapsedTime=0

		const tick =()=>{
			const elapsedTime =clock.getElapsedTime()
			const deltaTime=elapsedTime - lastElapsedTime
			lastElapsedTime = elapsedTime

			cube.rotation.y=Math.sin(elapsedTime)

			console.log('tick')
			renderer.render(scene, camera)

			window.requestAnimationFrame(tick)
		}

		tick()


	</script>

	<script>
		//const scene = new THREE.Scene();
		//const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		////PerspectiveCamera（透视摄像机）(视野角度（FOV）,长宽比（aspect ratio）,近截面（near）,远截面（far）)

		//const renderer = new THREE.WebGLRenderer();
		//renderer.setSize(window.innerWidth, window.innerHeight);
		//document.body.appendChild(renderer.domElement);
		////渲染器

		//const geometry = new THREE.BoxGeometry(1, 1, 1);   //BoxGeometry（立方体）
		//const material = new THREE.MeshBasicMaterial({ color: 0x92C3C8 });  //材质 顏色十六进制(hex colors)
		//const cube = new THREE.Mesh(geometry, material);  //Mesh（网格）网格包含一个几何体以及作用在此几何体上的材质
		//scene.add(cube); //调用scene.add()的时候，物体将会被添加到(0,0,0)坐标

		//camera.position.z = 5;  //相機位置


		////進行渲染  渲染循环”（render loop）或者“动画循环”（animate loop）
		////使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次 / 秒）
		//function animate() {
		//	requestAnimationFrame(animate);

		//	//使方塊旋轉
		//	cube.rotation.x += 0.01;
		//	cube.rotation.y += 0.01;

		//	renderer.render(scene, camera);
		//};

		//animate();
		
	</script>

}
