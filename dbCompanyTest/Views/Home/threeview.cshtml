
@section Style{
	<link rel="stylesheet" href="~/css/donutstyle.css">
}

<canvas class="webgl"></canvas>
<div class="loading-bar"></div>

<section class="one">
	<div class="container">
		<div class="hero">
			<h2>Abs are Cool.</h2>
			<h3>But have you ever tried donuts?</h3>
			<p>
				Lorem ipsum dolor sit amet consectetur adipisicing elit. Doloremque aliquid culpa, <br>
				providentvoluptatem excepturi id in quasi ea hic voluptate dicta amet explicabo <br>
				expedita ratione velit modi. Nisiquaerat illum amet quisquam iusto perferendis <br>
				ducimus aspernatur quia, repellendus beatae fugiat!
			</p>

		</div>
	</div>
</section>

<section class="two">
	<div class="container">
		<div class="hero">
			<h2>How we do</h2>
			<h3>Experiment width tasty <br>donuts recipe everytime</h3>
			<p>
				Lorem ipsum dolor sit amet consectetur adipisicing elit. Doloremque aliquid culpa, <br>
				providentvoluptatem excepturi id in quasi ea hic voluptate dicta amet explicabo <br>
				expedita ratione velit modi. Nisiquaerat illum amet quisquam iusto perferendis <br>
				ducimus aspernatur quia, repellendus beatae fugiat!
			</p>

		</div>
	</div>
</section>

<section class="three">
	<h1>HAPPY DONUT.</h1>
</section>

<!-- <script src="script.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.146.0/three.min.js"></script>
<!-- <script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"></script> -->
<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
<script src="./js/script.js"></script>





@section Scripts{
	<script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js" ></script>
	@*gsap*@
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>

	<script >
		            /**
             * Base
             */
            // Canvas
            const canvas = document.querySelector('canvas.webgl')

            /**
             * Loaders
             */
            const loadingBarElement = document.querySelector('.loading-bar')
            const bodyElement = document.querySelector('body')
            const loadingManager = new THREE.LoadingManager(
                () => {
                    window.setTimeout(() => {
                        gsap.to(overlayMaterial.uniforms.uAlpha, {
                            duration: 3,
                            value: 0,
                            delay: 1
                        })
                        gsap.to(overlayMaterial.uniforms.uAlpha, {
                            duration: 3,
                            value: 0,
                            delay: 1
                        })

                        loadingBarElement.classList.add('ended')
                        bodyElement.classList.add('loaded')
                        loadingBarElement.style.transform = ''

                    }, 500)
                },
                (itemUrl, itemsLoaded, itemsTotal) => {
                    console.log(itemUrl, itemsLoaded, itemsTotal)
                    const progressRatio = itemsLoaded / itemsTotal
                    loadingBarElement.style.transform = `scaleX(${progressRatio})`
                    console.log(progressRatio)
                },
                () => {

                }
            )
            const gltfLoader = new THREE.GLTFLoader(loadingManager)

            /**
             *  Textures
             */
            const textureLoader = new THREE.TextureLoader()
            const alphaShadow = textureLoader.load('/assets/texture/simpleShadow.jpg');

            // Scene
            const scene = new THREE.Scene()

            const sphereShadow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 1.5),
                new THREE.MeshBasicMaterial({
                    transparent: true,
                    color: 0x000000,
                    opacity: 0.5,
                    alphaMap: alphaShadow
                })
            )

            sphereShadow.rotation.x = -Math.PI * 0.5

            sphereShadow.position.y = -1
            sphereShadow.position.x = 1.5;

            scene.add(sphereShadow)

            /**
             * Overlay
             */
            const overlayGeometry = new THREE.PlaneGeometry(2, 2, 1, 1)
            const overlayMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uAlpha;
                    void main() {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, uAlpha);
                        // gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                `,
                uniforms: {
                    uAlpha: {
                        value: 1.0
                    }
                },
                transparent: true
            })
            const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
            scene.add(overlay)


            /**
             * GLTF Model
             */

            let donut = null
            let rocket = null
            let base = new THREE.Object3D()
            let mixer;
            scene.add(base)
            //抓取3d檔
            gltfLoader.load(
            'https://rawcdn.githack.com/th9716/3dglb/f14a3ad7320f963f544f64607783ce7d18af4e21/cheesecake.glb',
                (gltf) => {
                    console.log(gltf);

                    donut = gltf.scene

                    const radius = 0.05

                    donut.position.x = 200;
                    donut.position.y = 0;
                    donut.position.z = 250;

                    donut.rotation.y =Math.PI * 0.18
                    donut.rotation.z =  Math.PI * 0.15

                    donut.scale.set(radius, radius, radius)

                    //base.add(donut)
                    scene.add(donut)

                    //mixer
                mixer = new THREE.AnimationMixer(donut);
                mixer.clipAction(gltf.animations[0]).setDuration(0.875).play();

                },
                (progress) => {
                    console.log(progress);
                },
                (error) => {
                    console.error(error);
                }
            )

            //rocket
        gltfLoader.load(
            "https://rawcdn.githack.com/th9716/3dglb/57d0aa3d7b2b54e4f74bcbf50e672bf50b259a2e/rocket.gltf",
            (gltf1) => {
                console.log(gltf1);

                rocket = gltf1.scene

                const radius = 2



                rocket.scale.set(radius, radius, radius)

                base.add(rocket)



                //const clips=gltf.animations;
                //const clip = THREE.AnimationClip.findByName(clips, 'Armature|ArmatureAction.002');
                //const action=mixer.clipAction(clip);
                //action.play();

            },
            (progress) => {
                console.log(progress);
            },
            (error) => {
                console.error(error);
            }
        )





            /**
             * Light
             */
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8)
            scene.add(ambientLight)

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
            directionalLight.position.set(1, 2, 0)

            directionalLight.castShadow = true
            scene.add(directionalLight)

            /**
             * Sizes
             */
            const sizes = {
                width: window.innerWidth,
                height: window.innerHeight
            }

            /**
             * Scroll
             */
            let scrollY = window.scrollY
            let currentSection = 0

            const transformDonut = [{
                    rotationY: 0.6,
                    positionX: 1.5
                },
                {
                    rotationY: -0.6,
                    positionX: -1.5
                },
                {
                    rotationY: 0.6314,
                    positionX: 0
                },
                {
                    rotationY: 0.6314,
                    positionX: 0
                },
            ]

            window.addEventListener('scroll', () => {

                scrollY = window.scrollY
                const newSection = Math.round(scrollY / sizes.height)

                console.log(newSection);
            //console.log(donut.position)
            //console.log(donut.rotation)
                if (newSection != currentSection) {
                    currentSection = newSection

                    if (!!donut) {
                        gsap.to(
                            donut.rotation, {
                                duration: 1.5,
                                ease: 'power2.inOut',
                                y: transformDonut[currentSection].rotationY
                            }
                        )
                        gsap.to(
                            donut.position, {
                                duration: 1.5,
                                ease: 'power2.inOut',
                                x: transformDonut[currentSection].positionX
                            }
                        )

                        gsap.to(
                            sphereShadow.position, {
                                duration: 1.5,
                                ease: 'power2.inOut',
                                x: transformDonut[currentSection].positionX - 0.2
                            }
                        )
                    }
                }
            })

            /**
             * Camera
             */
            // Base camera
        const camera = new THREE.PerspectiveCamera(90, sizes.width / sizes.height, 0.1, 100000) //視野角度 長寬比 近截角 遠截角
            camera.position.z = 1000
            scene.add(camera)

            /**
             * Renderer
             */
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            })
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.PCFSoftShadowMap
            renderer.setSize(sizes.width, sizes.height)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))



        //mouse move
        let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -2)
        let raycaster = new THREE.Raycaster()
        let mouse = new THREE.Vector2()
        let pointOfIntersection = new THREE.Vector3()
        document.addEventListener('mousemove', onMouseMove, false)

        const cursorPos = new THREE.Vector2()
        const cursorBorderPos = new THREE.Vector2()

        function onMouseMove(e) {
            console.log(e)

            cursorPos.x = e.clientX-1000
            cursorPos.y = -(e.clientY-500)

            //mouse.x = (cursorPos.x / sizes.width) * 2 - 1
            //mouse.y = -(cursorPos.x / sizes.width) * 2 + 1

            rocket.position.set(cursorPos.x, cursorPos.y,-50)


        }





        //// When the mouse moves, call the given function
        //document.addEventListener('mousemove', onMouseMove, false);


        //// Follows the mouse event
        //function onMouseMove(e) {

        //    // Update the mouse variable
        //    e.preventDefault();
        //    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        //    mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

        //    // Make the sphere follow the mouse
        //    var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        //    vector.unproject(camera);
        //    var dir = vector.sub(camera.position).normalize();
        //    var distance = - camera.position.z / dir.z;
        //    var pos = camera.position.clone().add(dir.multiplyScalar(distance));
        //    rocket.position.copy(pos);

        //    // Make the sphere follow the mouse
        //    //	mouseMesh.position.set(event.clientX, event.clientY, 0);
        //};





            /**
             * Animate
             */

            

            const clock = new THREE.Clock()
            let lastElapsedTime = 0
            let prevTime = Date.now();

            const tick = () => {
                const elapsedTime = clock.getElapsedTime()
                const deltaTime = elapsedTime - lastElapsedTime
                lastElapsedTime = elapsedTime

                if (!!donut) {
                    donut.position.y = Math.sin(elapsedTime * .5) * .1 - 0.1
                    sphereShadow.material.opacity = (1 - Math.abs(donut.position.y)) * 0.3
                }

            //shiba mixer
            if (mixer) {
                const time = Date.now();
                mixer.update((time - prevTime) * 0.001);
                prevTime = time;
            }



                //mixer.update(clock.getDelta);

                // Render
                renderer.render(scene, camera)

                // Call tick again on the next frame
                window.requestAnimationFrame(tick)
            }

            tick()

            /**
             * On Reload
             */
            window.onbeforeunload = function () {
                window.scrollTo(0, 0);
            }


	</script>



	<script>
		//const scene = new THREE.Scene();
		//const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		////PerspectiveCamera（透视摄像机）(视野角度（FOV）,长宽比（aspect ratio）,近截面（near）,远截面（far）)

		//const renderer = new THREE.WebGLRenderer();
		//renderer.setSize(window.innerWidth, window.innerHeight);
		//document.body.appendChild(renderer.domElement);
		////渲染器


		//const loader = new THREE.GLTFLoader();

		//loader.load("https://rawcdn.githack.com/mrdoob/three.js/7249d12dac2907dac95d36227d62c5415af51845/examples/models/gltf/Flamingo.glb", function (gltf) {

		//	scene.add( gltf.scene );

		//}, undefined, function ( error ) {

		//	console.error( error );

		//} );


		////const geometry = new THREE.BoxGeometry(1, 1, 1);   //BoxGeometry（立方体）
		////const material = new THREE.MeshBasicMaterial({ color: 0x92C3C8 });  //材质 顏色十六进制(hex colors)
		////const cube = new THREE.Mesh(geometry, material);  //Mesh（网格）网格包含一个几何体以及作用在此几何体上的材质
		////scene.add(cube); //调用scene.add()的时候，物体将会被添加到(0,0,0)坐标

		//camera.position.z = 5;  //相機位置


		////進行渲染  渲染循环”（render loop）或者“动画循环”（animate loop）
		////使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次 / 秒）
		//function animate() {
		//	requestAnimationFrame(animate);

		//	//使方塊旋轉
		//	//cube.rotation.x += 0.01;
		//	//cube.rotation.y += 0.01;

		//	renderer.render(scene, camera);
		//};

		//animate();
		
	</script>

}
