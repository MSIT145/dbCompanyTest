
@section Style{
	<link rel="stylesheet" href="~/css/donutstyle.css">
}

<canvas class="webgl"></canvas>
<div class="loading-bar"></div>

<section class="one">
	<div class="container">
		<div class="hero">
			<h2>Abs are Cool.</h2>
			<h3>But have you ever tried donuts?</h3>
			<p>
				Lorem ipsum dolor sit amet consectetur adipisicing elit. Doloremque aliquid culpa, <br>
				providentvoluptatem excepturi id in quasi ea hic voluptate dicta amet explicabo <br>
				expedita ratione velit modi. Nisiquaerat illum amet quisquam iusto perferendis <br>
				ducimus aspernatur quia, repellendus beatae fugiat!
			</p>

		</div>
	</div>
</section>

<section class="two">
	<div class="container">
		<div class="hero">
			<h2>How we do</h2>
			<h3>Experiment width tasty <br>donuts recipe everytime</h3>
			<p>
				Lorem ipsum dolor sit amet consectetur adipisicing elit. Doloremque aliquid culpa, <br>
				providentvoluptatem excepturi id in quasi ea hic voluptate dicta amet explicabo <br>
				expedita ratione velit modi. Nisiquaerat illum amet quisquam iusto perferendis <br>
				ducimus aspernatur quia, repellendus beatae fugiat!
			</p>

		</div>
	</div>
</section>

<section class="three">
	<h1>HAPPY DONUT.</h1>
</section>




@section Scripts{
	<script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
	<script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js" ></script>
    <script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
@*    <script src="https://unpkg.com/browse/cannon@0.6.2/tools/threejs/CannonDebugRenderer.js"></script>
*@	@*gsap*@
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>

	<script >


        // Cannon.js
        let world
        let groundBody
        let sphereBody
        let shibaBody
        let sphere
        let shiba1
        let friction = 0.5
        let restitution = 0.7
        let sphereGroundContact
        let shibaGroundContact


		            /**
             * Base
             */
            // Canvas
            const canvas = document.querySelector('canvas.webgl')

            /**
             * Loaders
             */
            const loadingBarElement = document.querySelector('.loading-bar')
            const bodyElement = document.querySelector('body')
            const loadingManager = new THREE.LoadingManager(
                () => {
                    window.setTimeout(() => {
                        gsap.to(overlayMaterial.uniforms.uAlpha, {
                            duration: 3,
                            value: 0,
                            delay: 1
                        })
                        gsap.to(overlayMaterial.uniforms.uAlpha, {
                            duration: 3,
                            value: 0,
                            delay: 1
                        })

                        loadingBarElement.classList.add('ended')
                        bodyElement.classList.add('loaded')
                        loadingBarElement.style.transform = ''

                    }, 500)
                },
                (itemUrl, itemsLoaded, itemsTotal) => {
                    console.log(itemUrl, itemsLoaded, itemsTotal)
                    const progressRatio = itemsLoaded / itemsTotal
                    loadingBarElement.style.transform = `scaleX(${progressRatio})`
                    console.log(progressRatio)
                },
                () => {

                }
            )
            const gltfLoader = new THREE.GLTFLoader(loadingManager)

            /**
             *  Textures
             */
            const textureLoader = new THREE.TextureLoader()
            const alphaShadow = textureLoader.load('/assets/texture/simpleShadow.jpg');

            // Scene
            const scene = new THREE.Scene()

            const sphereShadow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 1.5),
                new THREE.MeshBasicMaterial({
                    transparent: true,
                    color: 0x000000,
                    opacity: 0.5,
                    alphaMap: alphaShadow
                })
            )

            sphereShadow.rotation.x = -Math.PI * 0.5

            sphereShadow.position.y = -1
            sphereShadow.position.x = 1.5;

            scene.add(sphereShadow)

            /**
             * Overlay
             */
            const overlayGeometry = new THREE.PlaneGeometry(2, 2, 1, 1)
            const overlayMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uAlpha;
                    void main() {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, uAlpha);
                        // gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                `,
                uniforms: {
                    uAlpha: {
                        value: 1.0
                    }
                },
                transparent: true
            })
            const overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
            scene.add(overlay)


            /**
             * GLTF Model
             */

            let donut = null
            let rocket = null
            let base = new THREE.Object3D()
            let mixer;
            scene.add(base)
            //抓取3d檔
            gltfLoader.load(
            'https://rawcdn.githack.com/th9716/3dglb/f14a3ad7320f963f544f64607783ce7d18af4e21/cheesecake.glb',
                (gltf) => {
                    console.log(gltf);

                    donut = gltf.scene

                    const radius = 0.05

                    donut.position.x = 150;
                    donut.position.y = 0;
                    donut.position.z = 250;

                    donut.rotation.y =Math.PI * 0.18
                    donut.rotation.z =  Math.PI * 0.15

                    donut.scale.set(radius, radius, radius)

                    //base.add(donut)
                    scene.add(donut)


                    //獲取模型外框範圍
                    //let bbox = new THREE.Box3().setFromObject(donut);
                    //let helper = new THREE.Box3Helper(bbox, new THREE.Color(0, 255, 0));
                    //let size = bbox.getSize(new THREE.Vector3());
                    //scene.add(helper);

                    //mixer
                mixer = new THREE.AnimationMixer(donut);
                mixer.clipAction(gltf.animations[0]).setDuration(0.875).play();

                },
                (progress) => {
                    console.log(progress);
                },
                (error) => {
                    console.error(error);
                }
            )



            /**
             * Light
             */
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8)
            scene.add(ambientLight)

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
            directionalLight.position.set(1, 2, 0)

            directionalLight.castShadow = true
            scene.add(directionalLight)

            /**
             * Sizes
             */
            const sizes = {
                width: window.innerWidth,
                height: window.innerHeight
            }

            /**
             * Scroll
             */
            let scrollY = window.scrollY
            let currentSection = 0

            const transformDonut = [{
                    rotationY: 0.6,
                    positionX: 0
                },
                {
                    rotationY: -0.6,
                    positionX: 0
                },
                {
                    rotationY: 0.6314,
                    positionX: 0
                },
                {
                    rotationY: 0.6314,
                    positionX: 0
                },
            ]

            window.addEventListener('scroll', () => {

                scrollY = window.scrollY
                const newSection = Math.round(scrollY / sizes.height)

                console.log(newSection);
            //console.log(donut.position)
            //console.log(donut.rotation)
                if (newSection != currentSection) {
                    currentSection = newSection

                    if (!!donut) {
                        gsap.to(
                            donut.rotation, {
                                duration: 1.5,
                                ease: 'power2.inOut',
                                y: transformDonut[currentSection].rotationY
                            }
                        )
                        //gsap.to(
                        //    donut.position, {
                        //        duration: 1.5,
                        //        ease: 'power2.inOut',
                        //        x: transformDonut[currentSection].positionX
                        //    }
                        //)

                        gsap.to(
                            sphereShadow.position, {
                                duration: 1.5,
                                ease: 'power2.inOut',
                                x: transformDonut[currentSection].positionX - 0.2
                            }
                        )
                    }
                }
            })

            /**
             * Camera
             */
            // Base camera
        const camera = new THREE.PerspectiveCamera(90, sizes.width / sizes.height, 0.1, 100000) //視野角度 長寬比 近截角 遠截角
            camera.position.z = 1000
            scene.add(camera)

            /**
             * Renderer
             */
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            })
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.PCFSoftShadowMap
            renderer.setSize(sizes.width, sizes.height)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))



        //mouse move
        let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -2)
        let raycaster = new THREE.Raycaster()
        let mouse = new THREE.Vector2()
        let pointOfIntersection = new THREE.Vector3()
        document.addEventListener('mousemove', onMouseMove, false)

        const cursorPos = new THREE.Vector2()
        const cursorBorderPos = new THREE.Vector2()

        function onMouseMove(e) {
            console.log(e)

            cursorPos.x = e.clientX - 1000
            cursorPos.y = -(e.clientY - 500)

            //cursorPos.x = e.clientX 
            //cursorPos.y = -e.clientY

            //mouse.x = (cursorPos.x / sizes.width) * 2 - 1
            //mouse.y = -(cursorPos.x / sizes.width) * 2 + 1

            rocket.position.set(cursorPos.x, cursorPos.y,250)



        }


        function initCannonWorld() {
            // 建立物理世界
            world = new CANNON.World()

            // 設定重力場為 y 軸 -9.8 m/s²
            world.gravity.set(0, -9.8, 0)

            // 碰撞偵測
            world.broadphase = new CANNON.NaiveBroadphase()

            // 建立地板剛體
            let groundShape = new CANNON.Plane()
            let groundCM = new CANNON.Material()
            groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(5, -500, 0),
                material: groundCM
            })
            // setFromAxisAngle 旋轉 x 軸 -90 度
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
            world.add(groundBody)


            //建立圓柱
            let shibashape = new CANNON.Cylinder(150, 150, 500, 16);
            let shibaCM = new CANNON.Material();
            shibaBody = new CANNON.Body({
                mass: 0,
                shape: shibashape,
                position: new CANNON.Vec3(5, 0, 0),
                material: shibaCM
            })
            world.add(shibaBody)


            // 建立球剛體
            let sphereShape = new CANNON.Sphere(150)
            let sphereCM = new CANNON.Material()
            sphereBody = new CANNON.Body({
                mass: 5,
                shape: sphereShape,
                position: new CANNON.Vec3(0, 600, 250),
                material: sphereCM
            })
            world.add(sphereBody)


            // 設定兩剛體碰撞時交互作用屬性
            sphereGroundContact = new CANNON.ContactMaterial(groundCM, sphereCM, {
                friction: friction, // 摩擦力
                restitution: restitution // 恢復係數, 衡量兩個物體碰撞後反彈程度
            })
            world.addContactMaterial(sphereGroundContact)

            // 設定兩剛體碰撞時交互作用屬性
            shibaGroundContact = new CANNON.ContactMaterial(groundCM, shibaCM, {
                friction: 0.8, // 摩擦力
                restitution: 1.5 // 恢復係數, 衡量兩個物體碰撞後反彈程度
            })
            world.addContactMaterial(shibaGroundContact)

            // 設定兩剛體碰撞時交互作用屬性
            let ballGroundContact = new CANNON.ContactMaterial(sphereCM, shibaCM, {
                friction: 0.8, // 摩擦力
                restitution: 0.8 // 恢復係數, 衡量兩個物體碰撞後反彈程度
            })
            world.addContactMaterial(ballGroundContact)

            // 地板網格外觀
            let groundGeometry = new THREE.PlaneGeometry(20, 20, 32)
            let groundMaterial = new THREE.MeshLambertMaterial({
                color: 0xa5a5a5,
                side: THREE.DoubleSide
            })
            let ground = new THREE.Mesh(groundGeometry, groundMaterial)
            ground.rotation.x = -Math.PI / 2
            ground.receiveShadow = true
            scene.add(ground)

            // 球網格外觀
            let sphereGeometry = new THREE.SphereGeometry(150, 32, 32)
            let sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x33aaaa })
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)
            sphere.castShadow = true
            scene.add(sphere)

            // 圓柱網格外觀
            //let shibaGeometry = new THREE.CylinderGeometry(150, 150, 500, 16)
            //let shibaMaterial = new THREE.MeshStandardMaterial({ color: 0xD5BCA7 })
            //shiba1 = new THREE.Mesh(shibaGeometry, shibaMaterial)
            //shiba1.castShadow = true
            //scene.add(shiba1)

            //rocket
            gltfLoader.load(
                "https://rawcdn.githack.com/th9716/3dglb/57d0aa3d7b2b54e4f74bcbf50e672bf50b259a2e/rocket.gltf",
                (gltf1) => {
                    console.log(gltf1);

                    rocket = gltf1.scene

                    const radius = 2


                    rocket.scale.set(radius, radius, radius)

                    base.add(rocket)
                    console.log(rocket.size)


                    //const clips=gltf.animations;
                    //const clip = THREE.AnimationClip.findByName(clips, 'Armature|ArmatureAction.002');
                    //const action=mixer.clipAction(clip);
                    //action.play();

                },
                (progress) => {
                    console.log(progress);
                },
                (error) => {
                    console.error(error);
                }
            )

        }






            /**
             * Animate
             */



            const clock = new THREE.Clock()
            let lastElapsedTime = 0
            let prevTime = Date.now();

            const timeStep = 1.0 / 60.0 // seconds

            const tick = () => {
                const elapsedTime = clock.getElapsedTime()
                const deltaTime = elapsedTime - lastElapsedTime
                lastElapsedTime = elapsedTime


                if (!!donut) {
                    donut.position.y = Math.sin(elapsedTime * .5) * .1 - 0.1
                    sphereShadow.material.opacity = (1 - Math.abs(donut.position.y)) * 0.3
                }

            //shiba mixer
            if (mixer) {
                const time = Date.now();
                mixer.update((time - prevTime) * 0.001);
                prevTime = time;
            }


            world.step(timeStep)
            if (sphere) {
                sphere.position.copy(sphereBody.position)
                sphere.quaternion.copy(sphereBody.quaternion)
            }
            if (shiba1) {
                rocket.position.copy(shibaBody.position)
                rocket.quaternion.copy(shibaBody.quaternion)
                console.log(rocket.position)
                console.log(shibaBody.position)
            }


                //mixer.update(clock.getDelta);

                // Render
                renderer.render(scene, camera)

                // Call tick again on the next frame
                window.requestAnimationFrame(tick)
            }

            initCannonWorld()
            tick()

            /**
             * On Reload
             */
            window.onbeforeunload = function () {
                window.scrollTo(0, 0);
            }


	</script>




}
